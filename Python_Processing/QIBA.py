"""
    
QIBA.py

This script contains the driving functions to analyze ARFI-SWEI data
generated by the VerasonicsPhantomSequences RSNA-QIBA-US-SWS repository.

Author: Kaden Bock (04/01/2025)
    
"""

import os
import glob
import tqdm.notebook as tqdm
import numpy as np
import QIBAOutput
from scipy.io import savemat
from processing_functions import AnalysisPar
from processing_functions import DataAcqPar
from processing_functions import QIBAPlotPar
from processing_functions import genDisp
from processing_functions import SpaceTimePlotSetUp as STPSU
from processing_functions import SpaceTimePlotAnalysis as STPA

def Analyze_All_Acquisitions(pwd:str, analysis_params:AnalysisPar.AnalysisPar, plot_params:QIBAPlotPar.QIBAPlotPar):
    """ This function performs the batch analysis consistent with the AnalyzeAllAcquisitions.m
        matlab script from previous versions, and returns the group speed and dispersion curve
        for the data.

    Args:
        pwd (str): The primary working directory that contains the raw data from the QIBA
            data acquisition script. Output processing files will also be stored here.
        analysis_params (AnalysisPar.AnalysisPar): An AnalysisPar object that holds all
            of the parameters used to perform analysis on the collected data.
        plot_params (QIBAPlotPar.QIBAPlotPar): A QIBAPlotPar object that holds all of the
            parameters used to generate the final output plot.

    Returns:
        QIBAOutputObj: A QIBA output object that holds the processed output data.
    """
    
    # Gather all acquisitions files
    all_parameter_files = glob.glob(os.path.join(pwd, "*_parameters.mat")) 
    
    # Create an output object to store outputs
    QIBAOutput_obj = QIBAOutput.generate_QIBA_output_object(analysis_params) 
        
    print("Total Acquisitions Found: {}".format(len(all_parameter_files)))
    
    print("Processing Acquisition...:")
    
    for par_file in tqdm.tqdm(all_parameter_files, total=len(all_parameter_files)):
        
        # Create a DataAcqPar object to store acquisition parameters
        acq_params = DataAcqPar.create_DataAcqPar_from_QIBA_file(par_file) 
        
        # Process acquisition for displacement data
        output_disp_data_dict = generate_disp_data_for_acq(acq_params, analysis_params) 
        
        # Generate Spacetime Plots for the acquisition
        output_disp_and_vel_STP_dict = generate_disp_and_vel_spacetime_plots(output_disp_data_dict, analysis_params)
        
        # Process the SpaceTime Plots for group speed and dispersion
        output_ph_vel_and_gSWS_data_dict = analyze_STPs_for_group_and_phase_velocity(output_disp_and_vel_STP_dict,
                                                                                     analysis_params, acq_params=acq_params)
        
        # Add processed data to the output object
        QIBAOutput_obj.add_output_of_QIBA_Processing_data(output_ph_vel_and_gSWS_data_dict, acq_params)
    
    filter_SWSs_and_display_final_outputs(QIBAOutput_obj, plot_params)
    
    return QIBAOutput_obj

    
def generate_disp_data_for_acq(acq_params:DataAcqPar.DataAcqPar, analysis_params:AnalysisPar.AnalysisPar, saving:int=1):
    """ Generates the displacement data for a given acquisitions, in microns.

    Args:
        acq_params (DataAcqPar.DataAcqPar): The DataAcqPar object associated with this
            acquisition.
        analysis_params (AnalysisPar.AnalysisPar): The AnalysisPar object which stores
            the processing parameters for all acquisitions.
        saving (int, optional): Save-file toggle. Defaults to 1 to enable save-file outputs.

    Returns:
        dict: An output dictionary that contains the processed data.
    """
    
    # Load the IQ data for the acquisition
    IData, QData = acq_params.load_IQData()
    
    IQData = IData + 1j*QData
    
    # Calculate the number of pixels corresponding to the given kasai kernel size
    kernel_size_px = acq_params.calc_num_pixels_for_num_WL(analysis_params.kasai_kernel_size_WL)
    
    # Generate the displacement data using Kasai's algorithm
    disp_data = genDisp.calc_particle_displacement_using_kasai(IQData, acq_params.num_refs, kernel_size_px, 
                                                              acq_params.c_mps, acq_params.track_freq_MHz)
    # disp_data = genDisp.phase_unwrap_displacement_estimate(disp_data, acq_params.c_mps, acq_params.track_freq_MHz,
    #                                                        acq_params.num_refs+2, 2, 1, 1)
    
    # Format the output data dictionary
    output_dict = {}
    
    output_dict['arfidata'] = disp_data
    output_dict['axial'] = acq_params.ax_axis_mm/10 # Saving in CM to match previous versions
    output_dict['lat'] = acq_params.lat_axis_mm/10 # Saving in CM to match previous verisions
    output_dict['num_refs'] = acq_params.num_refs
    output_dict['push_focus'] = acq_params.push_focus_mm
    output_dict['T'] = acq_params.T
        
    if saving:
        filename = acq_params.filestamp + "_fromIQ_arfidata.mat"
        full_file_dir = os.path.join(acq_params.directory_path, filename)
        
        # Save the output file as a .mat file
        savemat(full_file_dir, output_dict)
        
    return output_dict

def generate_disp_and_vel_spacetime_plots(output_disp_data_dict:dict, analysis_params:AnalysisPar.AnalysisPar):
    """ Driver function for generating spacetime plots for a given axial plane for a given acquisition.

    Args:
        output_disp_data_dict (dict): Output dictionary of the previous function, containing all the
            data from displacement data processing.
        analysis_params (AnalysisPar.AnalysisPar): The AnalysisPar object which stores
            the processing parameters for all acquisitions.

    Returns:
        dict: An output dictionary containing both Spacetime plots, labeled FL0 and FL1 for the
            leftward and rightward propagating shear waves, respectively
    """
    
    # Determine the axial depth at which to process the data
    if analysis_params.axial_processing_depth == "push_focus":
        processing_depth_center_mm = output_disp_data_dict['push_focus']
    else:
        processing_depth_center_mm = analysis_params.axial_processing_depth
        
    # Assign all of the output dict data structures to new variables for easier reference
    disp_data = output_disp_data_dict['arfidata']
    axial_ax_mm = output_disp_data_dict['axial']*10 # axial is saved in cm
    lat_ax_mm = output_disp_data_dict['lat']*10 # lateral is saved in cm
    T_ms = output_disp_data_dict['T']
    
    # Generate a displacement plane at a given axial depth, averaging over a certain axial extent
    disp_plane = STPSU.generate_disp_plane_at_depth(disp_data, axial_ax_mm, processing_depth_center_mm,
                                                   analysis_params.Depth_of_Field_to_average_mm)
    
    # Split the placement plane down a given lateral position, and return both planes and their axises 
    left_disp_plane, left_lat_ax_mm, right_disp_plane, right_lat_ax_mm = STPSU.split_disp_plane_down_axis(disp_plane, lat_ax_mm, 0, 0)
    
    # Setup the output dict
    output_dict = {
        "FL0" : {},
        "FL1" : {}
    }
    
    ind_names = ['FL0', 'FL1']
    
    both_planes = [left_disp_plane, right_disp_plane]
    both_axes = [left_lat_ax_mm, right_lat_ax_mm]

    # Set up the range limits for analysis
    lat_range = (analysis_params.min_lat_mm, analysis_params.max_lat_mm)
    t_ms_range = (analysis_params.min_time_ms, analysis_params.max_time_ms)
  
    for ind, zipped_plane_info in enumerate(zip(both_planes, both_axes)):
        
        # Unpack the packed plane info
        plane, lat_ax_mm = zipped_plane_info
        
        # Limit the lateral extend of the displacement plane to fall within the limits
        plane, new_lat_ax = STPSU.limit_extent_of_disp_plane(plane, lat_ax_mm, lat_range, 0)
        
        # Remove reverb frames, and remove DC from the temporal extent of the spacetime plot
        plane, new_t_ms = STPSU.remove_and_fix_reverb_frames(plane, T_ms)
        
        # Apply a 2D temporal low-pass filter to the spacetime plot
        plane = STPSU.low_pass_filter_plane_in_time_2D(plane, new_t_ms, analysis_params.LPF_cutoff_kHz)
        
        # Limit the temporal extent of the spacetime plot
        plane, new_t_ms = STPSU.limit_extent_of_disp_plane(plane, new_t_ms, t_ms_range, 1)
        
        # Add 0s to match the min time ms value before the push frame
        plane, new_t_ms = STPSU.add_zeros_before_push_frame(plane, new_t_ms, t_ms_range[0])
        
        # Upsample the spacetime plot over the temporal axis
        plane, new_t_ms = STPSU.upsample_disp_plane_over_axis(plane, new_t_ms, analysis_params.desired_PRF_kHz, 1)
        
        # Apply a Tukey window over the spacetime plot
        plane = STPSU.apply_tukey_window_over_ax_edges(plane, new_t_ms, analysis_params.tukey_alpha)
        
        # Generate a velocity-data spacetime plot by differentiating the displacement data over the time axis
        vel_plane, vel_t_ms = STPSU.differentiate_disp_plane_to_generate_vel_plane(plane, new_t_ms)
        
        # Grab the correct-side dict for saving outputs
        sub_dict = output_dict[ind_names[ind]]
            
        # Save outputs
        sub_dict['disp_plane'] = plane
        sub_dict['disp_lat_mm'] = new_lat_ax
        sub_dict['disp_t_ms'] = new_t_ms
        
        sub_dict['vel_plane'] = vel_plane
        sub_dict['vel_lat_mm'] = new_lat_ax
        sub_dict['vel_t_ms'] = vel_t_ms     
    
    return output_dict

def analyze_STPs_for_group_and_phase_velocity(output_disp_and_vel_STP_dict:dict, analysis_params:AnalysisPar.AnalysisPar, acq_params:DataAcqPar.DataAcqPar=None, saving:int=1):
    """ Process the generated spacetime plots to find their Time-to-peak based group velocity and 2D-Fourier 
            transform-based phase velocity

    Args:
        output_disp_and_vel_STP_dict (dict): The output dictionary from the previous function containing space-time plots
            for waves propagating in both directions.
        analysis_params (AnalysisPar.AnalysisPar): The AnalysisPar object which stores
            the processing parameters for all acquisitions.
        acq_params (DataAcqPar.DataAcqPar, optional): The DataAcqPar Object for the given acquisition. Only required
            for saving the outputs. Defaults to None.
        saving (int, optional): Save-file toggle. Defaults to 1 to enable save-file outputs.


    Raises:
        ValueError: In the event that the save-file flag is enabled, but no DataAcqPar object is provided to
            name the output data files.

    Returns:
        dict: An output dictionary containing all of the processed group and phase speeds.
    """
    
    output_dict = {}
    
    freqs_to_analyze = analysis_params.freqs_to_analyze
    
    for plane_side in output_disp_and_vel_STP_dict.keys():
        
        sub_dict = output_disp_and_vel_STP_dict[plane_side]
        
        # Run the TTP algorithm on the displacement-data spacetime plot to determine displacement group speed
        TTP_disp, Vdisp = STPA.run_TTP_to_determine_group_vel(sub_dict['disp_plane'], sub_dict['disp_t_ms'], 
                                                              sub_dict['disp_lat_mm'])
        
        # Run the TTP algorithm on the velocity-data spacetime plot to determine velocity group speed
        TTP_vel, Vvel = STPA.run_TTP_to_determine_group_vel(sub_dict['vel_plane'], sub_dict['vel_t_ms'], 
                                                              sub_dict['vel_lat_mm'])
        
        # Re-weight the velocity plot to do... something
        vel_weights = np.expand_dims(np.sqrt(sub_dict['vel_lat_mm']),1)
        
        weighted_vel_plane = sub_dict['vel_plane']*vel_weights
        
        # Generate speeds at each frequency for dispersion analysis
        phase_velocity_vec = STPA.calculate_phase_vel_from_2D_FT(weighted_vel_plane, sub_dict['vel_t_ms'], 
                                                                 sub_dict['vel_lat_mm'], freqs_to_analyze)
        
        # Save outputs to an output dictionary
        output_sub_dict = {
            "dispPlane" : sub_dict['disp_plane'],
            "freqsToAnalyze" : freqs_to_analyze,
            "latmm" : sub_dict['disp_lat_mm'],
            "phVel" : phase_velocity_vec,
            "tms" : sub_dict['disp_t_ms'],
            "TTPdisp" : TTP_disp,
            "TTPvel" : TTP_vel,
            "Vdisp" : Vdisp,
            "vellatmm" : sub_dict['vel_lat_mm'],
            "velPlane" : sub_dict['vel_plane'],
            "veltms" : sub_dict['vel_t_ms'],
            "VVel" : Vvel
        }
        
        if saving:
            if acq_params is None:
                raise ValueError("The acq params must be provided to this function "+
                                "in order to be saved")
            filename = acq_params.filestamp + "_"+ plane_side + "_phVel_gSWS_data.mat"
            full_file_dir = os.path.join(acq_params.directory_path, filename)
            
            savemat(full_file_dir, output_sub_dict)
        
        output_dict[plane_side] = output_sub_dict

    return output_dict


def filter_SWSs_and_display_final_outputs(QIBA_output:QIBAOutput.QIBAOutput, plot_params:QIBAPlotPar.QIBAPlotPar):
    """ Filters the output data for valid shear wave speeds, and displays and saves the final results.

    Args:
        QIBA_output (QIBAOutput.QIBAOutput): A QIBAOutput Object that contains all of the stored 
            SWS results
        plot_params (QIBAPlotPar.QIBAPlotPar): A QIBAPlotPar object that holds all of the
            parameters used to generate the final output plot.

    """
    
    # Filter output speeds for outliers    
    QIBA_output.filter_speeds_for_valid_data(plot_params)
    
    # Generate the final QIBA-style output plot
    QIBA_output.generate_QIBA_output_plot(plot_params)
    
    # Generate the final CSV file containing all outputs.
    QIBA_output.generate_QIBA_ouput_textfile(plot_params)
    
    return