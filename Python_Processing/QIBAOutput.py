"""

QIBAOutput.py

This script contains the infrastructure for the final output object generated by running
the QIBA processing routines.



Author: Kaden Bock (4/24/2025)


"""

import os
import pymatreader
import numpy as np
from IPython.display import Image
from functools import partial
from matplotlib import pyplot as plt
from matplotlib import animation as ani
from processing_functions import AnalysisPar
from processing_functions import DataAcqPar
from processing_functions import QIBAPlotPar
from processing_functions import OutlierRemoval as OR

class QIBAOutput:
    def __init__(self, analysis_params:AnalysisPar.AnalysisPar):
        """ Initialization function for the Output objects.
        
        These fields will be added to as results are generated.

        Args:
            analysis_params (AnalysisPar.AnalysisPar): The Analysis Parameters object
                which holds all of the analysis parameters for the given set of acquisitions
        """
        
        self.total_acqs = 0
        self.acq_timestamps = []
        self.include_dict = {}
        
        self.raw_disp_gSWSs = {}
        self.raw_vel_gSWSs = {}
        self.raw_phVels = {}
        
        self.freqs_to_analyze = analysis_params.freqs_to_analyze
        
        self.filtered_disp_gSWSs = []
        self.filtered_vel_gSWSs = []
        self.filtered_phVels = []
        
        self.analysis_params = analysis_params
        
        pass
    
    def add_output_of_QIBA_Processing_data(self, output_data_dict:dict, 
                                           acq_params:DataAcqPar.DataAcqPar):
        """ Adds the output of a processed acquisition to the overall output object.

        Args:
            output_data_dict (dict): The output dictionary containing the processed
                data for the single acquisition.
            acq_params (DataAcqPar.DataAcqPar): The DataAcqPar object associated with
                the acquisition.
        """
        
        acq_stamp = acq_params.filestamp
        
        self.total_acqs += 1
        self.acq_timestamps.append(acq_stamp)
        
        G_disp_SWS1 = output_data_dict['FL0']['Vdisp']
        G_disp_SWS2 = output_data_dict['FL1']['Vdisp']
        
        G_vel_SWS1 = output_data_dict['FL0']['VVel'] 
        G_vel_SWS2 = output_data_dict['FL1']['VVel']
        
        PhVel1 = output_data_dict['FL0']['phVel']
        PhVel2 = output_data_dict['FL1']['phVel']
        
        # Mark both sides of the displacement plane as valid independent SWS measurements
        self.include_dict[acq_stamp] = [True, True]
        self.raw_disp_gSWSs[acq_stamp] = (G_disp_SWS1, G_disp_SWS2)
        self.raw_vel_gSWSs[acq_stamp] = (G_vel_SWS1, G_vel_SWS2)
        self.raw_phVels[acq_stamp] = np.array([PhVel1, PhVel2])
    
        return
    
    def filter_speeds_for_valid_data(self, plot_params:QIBAPlotPar.QIBAPlotPar):
        """ Perform filtering on the collected data

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
        """
        
        # Add all data to the unfiltered arrays
        self.build_unfiltered_SWS_arrays()
        
        # Perform filtering on displacement data speeds    
        self.filtered_disp_gSWSs = OR.remove_outliers_based_on_set_thresholds(self.filtered_disp_gSWSs, 
                                                                            (plot_params.min_valid_gSWS, 
                                                                            plot_params.max_valid_gSWS))
        self.filtered_disp_gSWSs= OR.remove_outliers_based_on_std(self.filtered_disp_gSWSs, plot_params.th_factor)
        
        # Perform filtering on velocity data speeds    
        self.filtered_vel_gSWSs = OR.remove_outliers_based_on_set_thresholds(self.filtered_vel_gSWSs, 
                                                                            (plot_params.min_valid_gSWS, 
                                                                            plot_params.max_valid_gSWS))
        self.filtered_vel_gSWSs = OR.remove_outliers_based_on_std(self.filtered_vel_gSWSs, plot_params.th_factor)
        
        # Perform filtering on phase velocities
        self.filtered_phVels = OR.remove_outliers_based_on_set_thresholds(self.filtered_phVels, 
                                                                              (0, plot_params.max_phVel_speed))
        self.filtered_phVels = OR.remove_outliers_based_on_std(self.filtered_phVels, plot_params.th_factor, 0)
        
        return
    
    def build_unfiltered_SWS_arrays(self):
        """ Build the unfiltered shear wave speed arrays from all acquisitions marked as valid
            for inclusion.
        """
        
        disp_SWSs = []
        vel_SWSs = []
        ph_Vels = []
        
        for acq_num in self.acq_timestamps:
            for ind, inc in enumerate(self.include_dict[acq_num]):
                if inc: 
                    # If the acquisition has been marked as valid for inclusion, add the data 
                    # to the full array.
                    disp_vel = self.raw_disp_gSWSs[acq_num][ind]
                    vel_vel = self.raw_vel_gSWSs[acq_num][ind]
                    ph_vel_arr = self.raw_phVels[acq_num][ind]
                    
                    disp_SWSs.extend([disp_vel])
                    vel_SWSs.extend([vel_vel] )                
                    ph_Vels.extend([ph_vel_arr])
                
        # Convert the stored data to numpy arrays        
        self.filtered_disp_gSWSs = np.array(disp_SWSs)
        self.filtered_vel_gSWSs = np.array(vel_SWSs)
        self.filtered_phVels = np.array(ph_Vels)
        
        return
    
    def generate_QIBA_output_plot(self, plot_params:QIBAPlotPar.QIBAPlotPar, save:bool=True):
        """ Generates the final QIBA output plot, which displays both group speeds 
            and the phase-velocity dispersion curve.       

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
            save (bool, optional): Save-flag for saving the finalized output plot as a png.
                Defaults to True.
        """
        
        fig = plt.figure(num=0, clear=True, figsize=(9,3))
        
        subfigs = fig.subfigures(1,2, width_ratios=[1,2])
        
        # Group Speed Plot
        
        group_ax = subfigs[0].add_subplot(111)
        
        group_disp_mean = np.nanmean(self.filtered_disp_gSWSs)
        group_disp_std = np.nanstd(self.filtered_disp_gSWSs)
        
        group_vel_mean = np.nanmean(self.filtered_vel_gSWSs)
        group_vel_std = np.nanstd(self.filtered_vel_gSWSs)
        
        group_pos = [1, 2]
        
        group_vals = [group_disp_mean, group_vel_mean]
        
        disp_large_error = group_disp_mean*plot_params.error_bar_frac
        vel_large_error = group_vel_mean*plot_params.error_bar_frac
        group_errs_large = [disp_large_error, vel_large_error]
        
        disp_small_err = plot_params.conf_int_factor*group_disp_std
        vel_small_err = plot_params.conf_int_factor*group_vel_std
        group_errs_small = [disp_small_err, vel_small_err]
        
        group_ax.errorbar(group_pos, group_vals, group_errs_small, fmt='none', ecolor='k', elinewidth=2, capsize=2)
        group_ax.errorbar(group_pos, group_vals, group_errs_large, fmt='none', ecolor='grey', elinewidth=1, capsize=2)        
        
        group_ax.set_ylim([0, plot_params.max_plot_speed])
        group_ax.set_xlim([0, 3])
        group_ax.set_xticks(group_pos, labels=["disp", 'vel'])
        group_ax.set_ylabel("group SWS (m/s)")
        
        # Phase Velocity Plot
        
        phase_ax = subfigs[1].add_subplot(111)
        
        phase_vel_means = np.nanmean(self.filtered_phVels, axis=0)
        phase_vel_stds = np.nanstd(self.filtered_phVels, axis=0)
        
        kr = 2*np.pi*self.freqs_to_analyze/phase_vel_means*plot_params.low_freq_cutoff_pos_min

        reject_stage_one = plot_params.conf_int_factor*phase_vel_stds
        reject_stage_two = plot_params.error_bar_frac*phase_vel_means
    
        phase_freq_slicer = (reject_stage_one<reject_stage_two) & (kr>=plot_params.kr_thresh)
        
        plotting_freqs = self.freqs_to_analyze[phase_freq_slicer]
        phase_vel_means = phase_vel_means[phase_freq_slicer]
        phase_vel_stds = phase_vel_stds[phase_freq_slicer]
        
        phase_vel_below = phase_vel_means*(1-plot_params.error_bar_frac)
        phase_vel_above = phase_vel_means*(1+plot_params.error_bar_frac)
               
        phase_errs_small = plot_params.conf_int_factor*phase_vel_stds
        
        phase_ax.errorbar(plotting_freqs, phase_vel_means, phase_errs_small, fmt='none', ecolor='k', elinewidth=2, capsize=2)
        phase_ax.fill_between(plotting_freqs, phase_vel_below, phase_vel_above, color='grey', alpha=0.5)
        
        phase_ax.set_ylim([0, plot_params.max_plot_speed])
        phase_ax.set_xlim([0, plot_params.max_plot_freq])
        phase_ax.set_ylabel("phase velocity (m/s)")
        phase_ax.set_xlabel("frequency (Hz)")
        phase_ax.set_title(plot_params.phantom_ID)
        
        plt.show()
        
        if save:
            output_dir = self.analysis_params.save_dir
            filename = os.path.join(output_dir, "gSWS_phVel_figure")
            plt.savefig(filename, format='png')
        
        return
    
    def generate_QIBA_ouput_textfile(self, plot_params:QIBAPlotPar.QIBAPlotPar):
        """ Writes an output csv-like file that contains all the processed group and phase
            velocities.

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
        """
        
        conf_int_frac = plot_params.conf_int_factor
        frac_error = plot_params.error_bar_frac
        
        file = os.path.join(self.analysis_params.save_dir, "gSWS_phVel_data.txt")
        
        fp = open(file, 'w')
        
        fp.write("\n")
        fp.write("phantom {}\n".format(plot_params.phantom_ID))
        fp.write('\n')
        fp.write(',group SWS (m/s),  {:.2}% CI,  {:.2}% mean\n'.format(conf_int_frac, frac_error))
        
        group_disp_mean = np.nanmean(self.filtered_disp_gSWSs)
        group_disp_std = np.nanstd(self.filtered_disp_gSWSs)
        
        fp.write("displacement,{:7.3f},{:7.3f},{:7.3f}\n".format(
            group_disp_mean, conf_int_frac*group_disp_std, frac_error*group_disp_mean
        ))
        
        group_vel_mean = np.nanmean(self.filtered_vel_gSWSs)
        group_vel_std = np.nanstd(self.filtered_vel_gSWSs)
        
        fp.write("velocity,{:7.3f},{:7.3f},{:7.3f}\n".format(
            group_vel_mean, conf_int_frac*group_vel_std, frac_error*group_vel_mean
        ))
        
        fp.write("\n\n")
        
        fp.write("frequency (Hz),phase velocity (m/s),  {:.2}% CI,  {:.2}% mean\n".format(conf_int_frac, frac_error))
        
        phase_vel_means = np.nanmean(self.filtered_phVels, axis=0)
        phase_vel_stds = np.nanstd(self.filtered_phVels, axis=0)
        
        kr = 2*np.pi*self.freqs_to_analyze/phase_vel_means*plot_params.low_freq_cutoff_pos_min

        reject_stage_one = plot_params.conf_int_factor*phase_vel_stds
        reject_stage_two = plot_params.error_bar_frac*phase_vel_means
    
        phase_freq_slicer = (reject_stage_one<reject_stage_two) & (kr>=plot_params.kr_thresh)
        
        plotting_freqs = self.freqs_to_analyze[phase_freq_slicer]
        phase_vel_means = phase_vel_means[phase_freq_slicer]
        phase_vel_stds = phase_vel_stds[phase_freq_slicer]
        
        for ind, freq in enumerate(plotting_freqs):
            fp.write("{:7.3f},{:7.3f},{:7.3f},{:7.3f}\n".format(
            freq, phase_vel_means[ind], conf_int_frac*phase_vel_stds[ind], frac_error*phase_vel_means[ind]
            ))
            
        fp.close()        
        
        return
    
    def show_spacetime_plot_for_acq(self, acq_timestamp:str, plane_type:str='velocity', side:str="both", clim:list | str="default"):
        """ This function loads the generated plane data during processing to show the generated space-time
            plot or plots.

        Args:
            acq_timestamp (str): The timestamp of the acq to be loaded.
            plane_type (str, optional): The type of plane to be loaded, can be either 'velocity' or 
                'displacement. Defaults to 'velocity'.
            side (str, optional): The direction of wave propagation to be loaded. Can be 'left', 'right', 
                or 'both'. Defaults to "both".
            clim (list | str, optional): The colorbar limits for the displayed spacetime plots. Defaults to
                'default', which is [-.3, .3] microns for velocity spacetime plots and [-3, 3] microns for
                displacement spacetime plots.

        Raises:
            KeyError: In the event that the inputs are not specified correctly.
        """
        
        plane_type = plane_type.strip()
        plane_type = plane_type.lower()        
        if plane_type not in ['velocity', 'displacement']:
            raise KeyError("The displayed plane type must either be 'velocity' or 'displacement.'")
        
        side = side.strip()
        side = side.lower()
        if side not in ['left', 'right', 'both']:
            raise KeyError("The lateral side displayed must either be 'left', 'right', or 'both'.")
        
        if clim == 'default':
            if plane_type == 'velocity':
                clim = [-.3, .3]
            else:
                clim = [-3, 3]
        
        side_key_options = {
            'left' : [0],
            'right' : [1],
            'both' : [0, 1]
        }
        
        dir = self.analysis_params.save_dir
        
        titles = ['Leftward', 'Rightward']
        
        for side_key in side_key_options[side]:
            mat_filename = os.path.join(dir, acq_timestamp + "_FL{}_phVel_gSWS_data.mat".format(side_key))
            
            loaded_dict = pymatreader.read_mat(mat_filename)
            
            if plane_type == 'velocity':
                tms = loaded_dict['veltms']
                latmm = loaded_dict['vellatmm']
                plane = loaded_dict['velPlane']
                vel = loaded_dict['VVel']
                
            else:
                tms = loaded_dict['tms']
                latmm = loaded_dict['latmm']
                plane = loaded_dict['dispPlane']
                vel = loaded_dict['Vdisp']
                
            aspect = (latmm[1] - latmm[0]) / (tms[1] - tms[0])
                
            plt.imshow(plane, extent = [tms[0], tms[-1], latmm[-1], latmm[0]], aspect=aspect)
            cbar = plt.colorbar()
            cbar.set_label("Displacement (microns)")
            plt.clim(clim)
            plt.xlabel("Time (ms)")
            plt.ylabel("Lateral Position (mm)")
            plt.suptitle("{} propgating wave for acq: ".format(titles[side_key]) + acq_timestamp)
            plt.title("Shear Wave Speed = {:4.2f} m/s".format(vel))
            
            plt.show()
                    
        return
    
    def generate_displacement_gif_for_acq(self, acq_timestamp:str, clim=[-3, 3]):
        """ Generates a lateral by axial displacment data gif for the specified acquisition.

        Args:
            acq_timestamp (str): The desired acquisition to generate a gif for.
            clim (list | str, optional): The colorbar limits for the displayed spacetime plots. Defaults to
                [-3, 3] microns.

        Returns:
            Image Object: A handle for the output gif file, re-read into memory so that it
                can be displayed neatly by the Juptyr notebook 
        """
        
        mat_filename = os.path.join(self.analysis_params.save_dir, acq_timestamp + "_fromIQ_arfidata.mat")
        
        loaded_dict = pymatreader.read_mat(mat_filename)
        
        latmm = loaded_dict['lat']*10
        axialmm = loaded_dict['axial']*10
        arfidata = loaded_dict['arfidata']
        T = loaded_dict['T']
        
        aspect = (axialmm[1] - axialmm[0]) / (latmm[1] - latmm[0])
        extent = [latmm[0], latmm[-1], axialmm[-1], axialmm[0]]
        
        fig = plt.figure(num=2, clear=True)
        ax = fig.add_subplot(111)
        
        ax.set_ylabel("Axial (mm)")
        ax.set_xlabel("Lateral (mm)")
        fig.suptitle("Acq: {}".format(acq_timestamp))
        fig.set_size_inches((4,4))
        
        im = ax.imshow(arfidata[:,:,0], extent=extent, aspect=aspect, vmin=clim[0], vmax=clim[1])
        
        cbar = fig.colorbar(im, ax=ax)
        cbar.set_label("Displacement (microns)")
        
        animation = ani.FuncAnimation(fig, partial(update_axis_for_fig_animation, ax=ax, arfidata=arfidata[:,:,1:], 
                                                   extent=extent, aspect=aspect, T=T, clim=clim), len(T)-1, interval=100)
        
        ani_filename = os.path.join(self.analysis_params.save_dir, acq_timestamp + "_disp_data.gif")
        animation.save(ani_filename)
        
        plt.close()
        
        return Image(open(ani_filename, 'rb').read(), format='png')
        
    
def generate_QIBA_output_object(analysis_params:AnalysisPar.AnalysisPar):
    """ Generates a QIBA output object and associates it with the given analysis parameters.

    Args:
        analysis_params (AnalysisPar.AnalysisPar): The Analysis Parameters object
            which holds all of the analysis parameters for the given set of acquisitions

    Returns:
        QIBAOutput: The QIBAOutput object which will hold all of the processed data
            for the set acquisitions
    """
    obj = QIBAOutput(analysis_params)
    return obj

def update_axis_for_fig_animation(i, ax, arfidata:np.array, extent:list, aspect:float, T:np.array, clim:list=[-3,3]):
    """ This function exists as the helper function to update the figure for the gif animation.

    Args:
        i (int): Iterater variable passed in by the animation fuction
        ax (plt.axes): The axies object that the image is drawn onto
        arfidata (np.array): The arfidata array that contains all of the displacement data for
            the acquisition.
        extent (list): The pre-computed extent of the image
        aspect (float): The pre-computed aspect of the image
        T (np.array): The time array that corresponds to the time each tracking frame was taken
        clim (list, optional) : The 
    """
    ax.imshow(arfidata[:,:,i], extent=extent, aspect=aspect, vmin=clim[0], vmax=clim[1])
    ax.set_title("T = {:4.2f} ms".format(T[i]))
    return
