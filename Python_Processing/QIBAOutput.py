"""

QIBAOutput.py

This script contains the infrastructure for the final output object generated by running
the QIBA processing routines.



Author: Kaden Bock (4/24/2025)


"""

import os
import numpy as np
from matplotlib import pyplot as plt
from processing_functions import AnalysisPar
from processing_functions import DataAcqPar
from processing_functions import QIBAPlotPar
from processing_functions import OutlierRemoval as OR

class QIBAOutput:
    def __init__(self, analysis_params:AnalysisPar.AnalysisPar):
        """ Initialization function for the Output objects.
        
        These fields will be added to as results are generated.

        Args:
            analysis_params (AnalysisPar.AnalysisPar): The Analysis Parameters object
                which holds all of the analysis parameters for the given set of acquisitions
        """
        
        self.total_acqs = 0
        self.acq_timestamps = []
        self.include_dict = {}
        
        self.raw_disp_gSWSs = {}
        self.raw_vel_gSWSs = {}
        self.raw_phVels = {}
        
        self.freqs_to_analyze = analysis_params.freqs_to_analyze
        
        self.filtered_disp_gSWSs = []
        self.filtered_vel_gSWSs = []
        self.filtered_phVels = []
        
        self.analysis_params = analysis_params
        
        pass
    
    def add_output_of_QIBA_Processing_data(self, output_data_dict:dict, 
                                           acq_params:DataAcqPar.DataAcqPar):
        """ Adds the output of a processed acquisition to the overall output object.

        Args:
            output_data_dict (dict): The output dictionary containing the processed
                data for the single acquisition.
            acq_params (DataAcqPar.DataAcqPar): The DataAcqPar object associated with
                the acquisition.
        """
        
        acq_stamp = acq_params.filestamp
        
        self.total_acqs += 1
        self.acq_timestamps.append(acq_stamp)
        
        G_disp_SWS1 = output_data_dict['FL0']['Vdisp']
        G_disp_SWS2 = output_data_dict['FL1']['Vdisp']
        
        G_vel_SWS1 = output_data_dict['FL0']['VVel'] 
        G_vel_SWS2 = output_data_dict['FL1']['VVel']
        
        PhVel1 = output_data_dict['FL0']['phVel']
        PhVel2 = output_data_dict['FL1']['phVel']
        
        # Mark both sides of the displacement plane as valid independent SWS measurements
        self.include_dict[acq_stamp] = [True, True]
        self.raw_disp_gSWSs[acq_stamp] = (G_disp_SWS1, G_disp_SWS2)
        self.raw_vel_gSWSs[acq_stamp] = (G_vel_SWS1, G_vel_SWS2)
        self.raw_phVels[acq_stamp] = np.array([PhVel1, PhVel2])
    
        return
    
    def filter_speeds_for_valid_data(self, plot_params:QIBAPlotPar.QIBAPlotPar):
        """ Perform filtering on the collected data

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
        """
        
        # Add all data to the unfiltered arrays
        self.build_unfiltered_SWS_arrays()
        
        # Perform filtering on displacement data speeds    
        self.filtered_disp_gSWSs = OR.remove_outliers_based_on_set_thresholds(self.filtered_disp_gSWSs, 
                                                                            (plot_params.min_valid_gSWS, 
                                                                            plot_params.max_valid_gSWS))
        self.filtered_disp_gSWSs= OR.remove_outliers_based_on_std(self.filtered_disp_gSWSs, plot_params.th_factor)
        
        # Perform filtering on velocity data speeds    
        self.filtered_vel_gSWSs = OR.remove_outliers_based_on_set_thresholds(self.filtered_vel_gSWSs, 
                                                                            (plot_params.min_valid_gSWS, 
                                                                            plot_params.max_valid_gSWS))
        self.filtered_vel_gSWSs = OR.remove_outliers_based_on_std(self.filtered_vel_gSWSs, plot_params.th_factor)
        
        # Perform filtering on phase velocities
        self.filtered_phVels = OR.remove_outliers_based_on_set_thresholds(self.filtered_phVels, 
                                                                              (0, plot_params.max_phVel_speed))
        self.filtered_phVels = OR.remove_outliers_based_on_std(self.filtered_phVels, plot_params.th_factor, 0)
        
        return
    
    def build_unfiltered_SWS_arrays(self):
        """ Build the unfiltered shear wave speed arrays from all acquisitions marked as valid
            for inclusion.
        """
        
        disp_SWSs = []
        vel_SWSs = []
        ph_Vels = []
        
        for acq_num in self.acq_timestamps:
            for ind, inc in enumerate(self.include_dict[acq_num]):
                if inc: 
                    # If the acquisition has been marked as valid for inclusion, add the data 
                    # to the full array.
                    disp_vel = self.raw_disp_gSWSs[acq_num][ind]
                    vel_vel = self.raw_vel_gSWSs[acq_num][ind]
                    ph_vel_arr = self.raw_phVels[acq_num][ind]
                    
                    disp_SWSs.extend([disp_vel])
                    vel_SWSs.extend([vel_vel] )                
                    ph_Vels.extend([ph_vel_arr])
                
        # Convert the stored data to numpy arrays        
        self.filtered_disp_gSWSs = np.array(disp_SWSs)
        self.filtered_vel_gSWSs = np.array(vel_SWSs)
        self.filtered_phVels = np.array(ph_Vels)
        
        return
    
    def generate_QIBA_output_plot(self, plot_params:QIBAPlotPar.QIBAPlotPar):
        """ Generates the final QIBA output plot, which displays both group speeds 
            and the phase-velocity dispersion curve.       

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
        """
        
        fig = plt.figure(num=0, clear=True, figsize=(9,3))
        
        subfigs = fig.subfigures(1,2, width_ratios=[1,2])
        
        # Group Speed Plot
        
        group_ax = subfigs[0].add_subplot(111)
        
        group_disp_mean = np.nanmean(self.filtered_disp_gSWSs)
        group_disp_std = np.nanstd(self.filtered_disp_gSWSs)
        
        group_vel_mean = np.nanmean(self.filtered_vel_gSWSs)
        group_vel_std = np.nanstd(self.filtered_vel_gSWSs)
        
        group_pos = [1, 2]
        
        group_vals = [group_disp_mean, group_vel_mean]
        
        disp_large_error = group_disp_mean*plot_params.error_bar_frac
        vel_large_error = group_vel_mean*plot_params.error_bar_frac
        group_errs_large = [disp_large_error, vel_large_error]
        
        disp_small_err = plot_params.conf_int_factor*group_disp_std
        vel_small_err = plot_params.conf_int_factor*group_vel_std
        group_errs_small = [disp_small_err, vel_small_err]
        
        group_ax.errorbar(group_pos, group_vals, group_errs_small, fmt='none', ecolor='k', elinewidth=2, capsize=2)
        group_ax.errorbar(group_pos, group_vals, group_errs_large, fmt='none', ecolor='grey', elinewidth=1, capsize=2)        
        
        group_ax.set_ylim([0, plot_params.max_plot_speed])
        group_ax.set_xlim([0, 3])
        group_ax.set_xticks(group_pos, labels=["disp", 'vel'])
        group_ax.set_ylabel("group SWS (m/s)")
        
        # Phase Velocity Plot
        
        phase_ax = subfigs[1].add_subplot(111)
        
        phase_vel_means = np.nanmean(self.filtered_phVels, axis=0)
        phase_vel_stds = np.nanstd(self.filtered_phVels, axis=0)
        
        kr = 2*np.pi*self.freqs_to_analyze/phase_vel_means*plot_params.low_freq_cutoff_pos_min

        reject_stage_one = plot_params.conf_int_factor*phase_vel_stds
        reject_stage_two = plot_params.error_bar_frac*phase_vel_means
    
        phase_freq_slicer = (reject_stage_one<reject_stage_two) & (kr>=plot_params.kr_thresh)
        
        plotting_freqs = self.freqs_to_analyze[phase_freq_slicer]
        phase_vel_means = phase_vel_means[phase_freq_slicer]
        phase_vel_stds = phase_vel_stds[phase_freq_slicer]
        
        phase_vel_below = phase_vel_means*(1-plot_params.error_bar_frac)
        phase_vel_above = phase_vel_means*(1+plot_params.error_bar_frac)
               
        phase_errs_small = plot_params.conf_int_factor*phase_vel_stds
        
        phase_ax.errorbar(plotting_freqs, phase_vel_means, phase_errs_small, fmt='none', ecolor='k', elinewidth=2, capsize=2)
        phase_ax.fill_between(plotting_freqs, phase_vel_below, phase_vel_above, color='grey', alpha=0.5)
        
        phase_ax.set_ylim([0, plot_params.max_plot_speed])
        phase_ax.set_xlim([0, plot_params.max_plot_freq])
        phase_ax.set_ylabel("phase velocity (m/s)")
        phase_ax.set_xlabel("frequency (Hz)")
        phase_ax.set_title(plot_params.phantom_ID)
        
        plt.show()
        
        return
    
    def generate_QIBA_ouput_textfile(self, plot_params:QIBAPlotPar.QIBAPlotPar):
        """ Writes an output csv-like file that contains all the processed group and phase
            velocities.

        Args:
            plot_params (QIBAPlotPar.QIBAPlotPar): The QIBAPlotPar object that contains
                all of the parameters used to plot the outputs.
        """
        
        file = os.path.join(self.analysis_params.save_dir, "gSWS_phVel_data.txt")
        
        fp = open(file, 'w')
        
        fp.write("\n")
        fp.write("phantom {}\n".format(plot_params.phantom_ID))
        fp.write('\n')
        fp.write(',group SWS (m/s),  95% CI,  30% mean\n')
        
        group_disp_mean = np.nanmean(self.filtered_disp_gSWSs)
        group_disp_std = np.nanstd(self.filtered_disp_gSWSs)
        
        fp.write("displacement,{:7.3f},{:7.3f},{:7.3f}\n".format(
            group_disp_mean, 1.95*group_disp_std, 0.3*group_disp_mean
        ))
        
        group_vel_mean = np.nanmean(self.filtered_vel_gSWSs)
        group_vel_std = np.nanstd(self.filtered_vel_gSWSs)
        
        fp.write("velocity,{:7.3f},{:7.3f},{:7.3f}\n".format(
            group_vel_mean, 1.95*group_vel_std, 0.3*group_vel_mean
        ))
        
        fp.write("\n\n")
        
        fp.write("frequency (Hz),phase velocity (m/s),  95% CI,  30% mean\n")
        
        phase_vel_means = np.nanmean(self.filtered_phVels, axis=0)
        phase_vel_stds = np.nanstd(self.filtered_phVels, axis=0)
        
        kr = 2*np.pi*self.freqs_to_analyze/phase_vel_means*plot_params.low_freq_cutoff_pos_min

        reject_stage_one = plot_params.conf_int_factor*phase_vel_stds
        reject_stage_two = plot_params.error_bar_frac*phase_vel_means
    
        phase_freq_slicer = (reject_stage_one<reject_stage_two) & (kr>=plot_params.kr_thresh)
        
        plotting_freqs = self.freqs_to_analyze[phase_freq_slicer]
        phase_vel_means = phase_vel_means[phase_freq_slicer]
        phase_vel_stds = phase_vel_stds[phase_freq_slicer]
        
        for ind, freq in enumerate(plotting_freqs):
            fp.write("{:7.3f},{:7.3f},{:7.3f},{:7.3f}\n".format(
            freq, phase_vel_means[ind], 1.95*phase_vel_stds[ind], 0.3*phase_vel_means[ind]
            ))
            
        fp.close()        
        
        return
    
def generate_QIBA_output_object(analysis_params:AnalysisPar.AnalysisPar):
    """ Generates a QIBA output object and associates it with the given analysis parameters.

    Args:
        analysis_params (AnalysisPar.AnalysisPar): The Analysis Parameters object
            which holds all of the analysis parameters for the given set of acquisitions

    Returns:
        QIBAOutput: The QIBAOutput object which will hold all of the processed data
            for the set acquisitions
    """
    obj = QIBAOutput(analysis_params)
    return obj
