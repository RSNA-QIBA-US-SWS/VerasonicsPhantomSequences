"""
    
SpaceTimePlotAnalysis.py

This script contains the helper functions to analyze space-time plots
generated from ARFI-SWEI data generated by the sequences in the 
RSNA-QIBA-US-SWS repository.

Author: Kaden Bock (04/08/2025)
    
"""

import numpy as np

# %% Group Velocity Analysis

def run_TTP_to_determine_group_vel(plane:np.array, t_ms:np.array, lat_mm:np.array,
                                   time_axis_num:int=1):
    """ Runs the Time-to-Peak (TTP) algorithm to determine the group velocity speed
        for the input space-time plot.
    
    Args:
        plane (np.array): The space-time plot of the data over which to run the algorithm.
        t_ms (np.array): The time vector of the space-time plot.
        lat_mm (np.array): The lateral position vector of the space-time plot.
        time_axis_num (int, optional): The axis number corresponding to the time axis of
            The space-time plot. Defaults to 1. The other axis is assumed to be the
            lateral position axis.

    Returns:
        np.array: A vector containing the time positions of all peaks.
        np.float: The group shear wave speed, in meters per second.
    """
    
    if plane.shape[time_axis_num] != t_ms.shape[0]:
        raise ValueError("The length of the time axis and the axis over which temporal"+
                         " information in the plane are not the same. Please"+
                         " double check and correct your inputs.")
    
    TTP_inds = np.argmax(plane, axis=time_axis_num)
    
    TTP = t_ms[TTP_inds]
    
    p = np.polyfit(lat_mm, TTP, deg=1)
    
    gSWS = 1/p[0]
    
    return TTP, gSWS

# %% Phase Velocity Analysis

def calculate_phase_vel_from_2D_FT(plane:np.array, t_ms:np.array, lat_mm:np.array,
                                   freqs_to_analyze:np.array, num_bins:int=2000):
    """ Calculates the phase velocities for all input frequencies.
    
    **NOTE:** This function assumes that lateral positions are indexed in the 0th axis, and
        temporal positions are indexed in the 1st axis.

    Args:
        plane (np.array): The space-time plot over which phase information should be calculated.
        t_ms (np.array): A vector corresponding to the temporal positioning information in the
            space-time plot.
        lat_mm (np.array): A vector corresponding to the lateral positioning information in
            the space-time plot.
        freqs_to_analyze (np.array): A vector containing all of the frequencies over which the
            phase velocities will be extracted.
        num_bins (int, optional): The number of bins which will be used to construct the 2D FFT. 
            Defaults to 2000.

    Raises:
        ValueError: In the event that the supplied vector shapes do not match the appropriate axises
            in the plane, or in the event that a requested frequency to extract phase velocity falls
            outside of the range of frequencies that are contained within the 2D FFT.

    Returns:
        np.array: A vector containing all of the extracted phase velocities at all frequencies.
    """
    
    if plane.shape[0] != lat_mm.shape[0]:
        raise ValueError("The length of the lateral vector and the axis over which lateral"+
                         " information in the plane is stored are not the same. Please"+
                         " double check and correct your inputs.")
    
    if plane.shape[1] != t_ms.shape[0]:
        raise ValueError("The length of the time vector and the axis over which temporal"+
                         " information in the plane is stored are not the same. Please"+
                         " double check and correct your inputs.")
        
    bin_vec = np.arange(-num_bins/2, num_bins/2, 1)
    
    dt = np.mean(np.diff(t_ms))/1000 # convert dt from ms to s
    fs = 1/dt
    f_t_vec = bin_vec*(fs/num_bins)
    
    dlat = np.mean(np.diff(lat_mm))/1000 # convert dlat from mm to m
    fs_lat = 1/dlat
    f_lat_vec = bin_vec*(fs_lat/num_bins)
    
    fft = np.fft.fft2(plane, s=(len(f_lat_vec), len(f_t_vec)))
    
    abs_fft = np.abs(np.fft.fftshift((fft)))
    
    phase_vels = np.zeros(len(freqs_to_analyze))
    
    for ind, freq in enumerate(freqs_to_analyze):
        
        if freq < f_t_vec[0] or freq > f_t_vec[-1]:
            raise ValueError("The requested frequency to analyze falls outside "+
                             "of the range of frequencies contained within the 2D fft.")
        
        f_t_bin_idx = np.argmin(np.abs(f_t_vec-freq))
        
        profile = abs_fft[:, f_t_bin_idx]
        
        f_lat_bin_idx = np.argmax(profile)
        
        if f_lat_bin_idx == 0 or f_lat_bin_idx==(len(f_lat_vec) -1):
            max_spacial_freq_val = f_lat_vec[f_lat_bin_idx]
        else: 
            y1 = profile[f_lat_bin_idx-1]
            y2 = profile[f_lat_bin_idx]
            y3 = profile[f_lat_bin_idx+1]
            
            interpolated_val = (y1-y3)/(y1-2*y2+y3)/2
            max_spacial_freq_val = f_lat_vec[f_lat_bin_idx] + interpolated_val*dlat
   
        phase_vels[ind] = -1* freq/max_spacial_freq_val

    return phase_vels